# Programming in Elixir

## Introduction

Intended audience is a beginner programmer. Note that code block can be evaluated by clicking on the *Evaluate* pop-up button.

Here is a definition for you to think about: `the square of a number X is defined as X multiplied by itself`.

It is a textual definition, not very hard to understand, but tedious to write out and hard to extend or modify, if you would like to do that.

We can use the language of Mathematics to express this in a shorter, and more exact way: 
$$X^2 = X*X$$

You could even define a function, like: $$square(X) = X*X$$

Now, if we use the Elixir programming language, one way we can define this function is:

<!-- livebook:{"force_markdown":true} -->

```elixir
square = fn(x) -> x*x end 
```

To call this function we can do as:

```elixir
square = fn x -> x * x end
square.(3)
```

What we defined above was an anonymous (unnamed) function `fn(x) -> ...`. The name `square = ...` is called a `variable` and can be seen as a little box with a name (*square*) where we put the anonymous function. On line 2 we run the function that we but into *square*. The result is output below the code block when the block is evaluated.

Another way of defining the *square* function in Elixir can be seen below:

```elixir
defmodule M do
  def square(x) do
    x * x
  end
end

M.square(3)
```

Here we first define something called a *module* with the name **M**. It encloses the rest of the code between the first *do* and last *end*.

In Elixir we group several functions into modules as a way to gather the code into logical units. It is a typical way of structuring your code (this is done in most programming languages actually).

## Data types

Note that we sent in the number 3 as an *argument* to our *square* function and that the function returned the number 9. The numbers in this case are actually whole numbers and we say that the are of the data type **integer**.

Here are some other example of data types:

* `3.14` is a **float**
* `:hello` is an **atom**
* `"Hello World"` is a **string**
* `true` is a **boolean**

A data type is a classification of data which tells the compiler or interpreter how the programmer intends to use the data.

So a *float* like `3.14` is a decimal number; compare this to an *integer* which is a whole number and does not have any decimals. An *atom* is simply a named constant, notice how they start with a colon (`:joe`). A *string* typically contains a text constructed of a series of characters, it is surrounded by a double quote (`"nice weather!"`). Finally, a *boolean* value can either have the value `true` or `false`.

<!-- livebook:{"break_markdown":true} -->

Next we have what is called aggregated types, i.e various collections of the data types we saw above. So we can have a **list** of integers:

<!-- livebook:{"force_markdown":true} -->

```elixir
[2,5,3,9,42]
```

We have something called **tuples**:

<!-- livebook:{"force_markdown":true} -->

```elixir
{:name, "Joe"}
```

A **list** can grow and shrink by adding or removing elements from it, while a **tuple** has a fixed number of elements that can't be changed.

We can only add to elements to the front of a list, as shown below:

<!-- livebook:{"force_markdown":true} -->

```elixir
an_empty_list = []
a_one_element_list = [42 | an_empty_list]
a_two_element_list = [9 | a_one_element_list]
```

Using the bar (`|`) we add a new element, placed on the left side, where we have our original list on the right side of the bar.

We can add several elements add once as shown here:

<!-- livebook:{"force_markdown":true} -->

```elixir
a_many_element_list = [2, 5, 3 | a_two_element_list]
```

Try it below, add some more elements:

```elixir
an_empty_list = []
a_one_element_list = [42 | an_empty_list]
a_two_element_list = [9 | a_one_element_list]
a_many_element_list = [2, 5, 3 | a_two_element_list]
a_many_element_list
```

## Functions

Manipulating Lists "manually", as we did above, quickly becomes tedious and impractical. The solution is to create functions that operate on lists. For example, let us create a function that calculate the sum of all the integers in a list. But first let us consider how a Mathematical definition could look like:

$$
sum([]) = 0
$$
First we define that the sum of an empty list is zero.
$$
sum([Head | Tail]) = Head + sum(Tail)
$$
Then we define that the sum of a list is the first element added to the sum of the remaining list.

This concept where we define our *sum* function in terms of itself is called *recursion*.
We created two defintions (*clauses*); the first definition covering the trivial base case of an empty list; the second definition, covering the recursive case, breaks down the problem by adding the first element to the remaining list.

Looking at the definition it seems pretty intuitive and fortunately we can almost write
some identical Elixir code that implements our *sum* function:

```elixir
defmodule A do
  def sum([]) do
    0
  end

  def sum([head | tail]) do
    head + sum(tail)
  end
end
```

The main difference is that we need to put our function in a module (**A**) and that we need to use a slightly different syntax for defining the two *sum* *function clauses*.

Now let's call our *sum* function:

```elixir
A.sum(a_many_element_list)
```

This recursive a pattern, and some very similar patterns, will show up again and again. So let us continue by writing a function *count* that counts the number of elements in a list.

Again, can we give a Mathematical definition?

$$
count([]) = 0
$$
An empty list has zero elements.
$$
count([Head | Tail]) = 1 + count(Tail)
$$
Remove the first element in the list and add one to the counting of the remaining list.

The corresponding Elixir function looks very similar:

```elixir
defmodule B do
  def count([]) do
    0
  end

  def count([_head | tail]) do
    1 + count(tail)
  end
end
```

Since we really isn't interested in the value of the first element in the list it is custom to add an underscore `_` in front of the variable (`_head`) to indicate this.

Now let's run our *count* function:

```elixir
B.count(a_many_element_list)
```

Now let us consider a very common variation of this recursive pattern. How would we define the function that reverses the order of the elements in the list.

Once again we can try to figure out a Math like definition:

$$
reverse([]) = []
$$
The base case is trivial, the reverse of an empty list is still an empty list.
$$
reverse([Head | Tail]) = reverse(Tail) ++ [Head]
$$
In the recursive case we have to introduce the append operator (`++`) that stitch together two lists. Note that we have to put the *Head* element in a list to make the append operator happy.

Again, we can implement this in Elixir:

```elixir
defmodule C do
  def reverse([]) do
    []
  end

  def reverse([head | tail]) do
    reverse(tail) ++ [head]
  end
end

C.reverse(a_many_element_list)
```

However, **this is not a good solution**! The reason is that the second clause is not *tail recursive*. To be *tail recursive*, a function must call itself as the last thing it does. In this case this is not the case. The append operation is the last thing that run in the second clause, since it has to wait for `reverse(tail)` to finish before it can stitch together the result.

(*A tail recursive function can execute in constant space, i.e it can reuse the same memory when it makes it recursive call since it doesn't have to return; it was the last call in the function remember. Compare this with a non tail recursive function that require new memory to be allocated for each recursive call.*)

So we need to rewrite our *reverse* function so that it become *tail recursive*. Fortunatly, this leads us to another very common recursive pattern:

```elixir
defmodule D do
  def reverse(list) do
    reverse(list, [])
  end

  defp reverse([], acc) do
    acc
  end

  defp reverse([head | tail], acc) do
    reverse(tail, [head | acc])
  end
end

D.reverse(a_many_element_list)
```

We have defined a helper function, also named *reverse* but which takes two argument. The second argument, called the *accumulator*, is the key to the solution here. We start with an empty *accumulator*, then we insert the first element in the *accumulator*, which will make this element to end up last in the *accumulator*. When all element has been traversed, we return the *accumulator* which now contain all the elements in reversed order.

<!-- livebook:{"break_markdown":true} -->

Time for some exersices. Try to implement the following function, as shown by the examples below:

<!-- livebook:{"force_markdown":true} -->

```elixir
[2,4,6] = E.double([1,2,3])

[3,6,9] = F.multiply([1,2,3], 3)

[0,1,2] = G.subtract([1,2,3], 1)

3 = H.last([1,2,3])

3 = I.mean([1,2,3])
```
